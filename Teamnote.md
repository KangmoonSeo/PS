<!-- update: 23.05.18. -->
# Teamnote
- c++ 기준으로 작성했습니다. 

--- 
## 목차
0. [기본 함수](#기본-함수)
1. [누적합](#누적합)
2. [구현](#구현)
3. [그래프 이론](#그래프-이론)
4. [DFS와 BFS](#dfs와-bfs)
5. [트리순회](#트리순회)
6. [완전탐색](#완전탐색)
7. [백트래킹](#백트래킹)
8. [비트마스킹](#비트마스킹)
9. [그리디](#그리디)
10. [라인스위핑](#라인스위핑)
11. [투포인터](#투포인터)
12. [LIS](#lis)
13. [이분탐색](#이분탐색)
14. [DP](#dp)
15. [최단거리](#최단거리)
16. [펜윅트리](#펜윅트리)
--- 
## 기본 함수
```cpp
fill_n(); // 사용 방법을 적어주세요
string.substr(); // 사용 방법을 적어주세요
```
--- 
## 누적합

sequence를 입력 받는 시점에서 미리 누적합으로 변환해 벡터에 저장한다. `// n * O(1)`

이후 벡터 구간을 사용할 때 `arr[b] - arr[a]` 로 꺼내 쓴다. `// O(1)`

```cpp
// 
```

--- 
## 구현
단계를 나눠서 구현. 큰돌 요약 참고

--- 
## 그래프 이론
- E = Edge = 간선
- V = Vertex = 정점

### 플로이드-워셜
 > 시간복잡도: O(V^3)
 - input: 
 - output: 
 ```cpp
 //
 ```
 
### 프림
 > 시간복잡도: O(V^2)
 - input: 
 - output: 
 ```cpp
 //
 ```

### 다익스트라
 > 시간복잡도: O(V^2)
 - input: 
 - output: 
 ```cpp
 //
 ```


--- 
## DFS와 BFS
adj matrix
```cpp
bool adj[100001][100001];
adj[i1][i2] = true;

```
adj list
```cpp
vector<int> adj[100001];
adj[i1].push_back(i2);
``
```cpp
bool visited[100001];

```

### DFS
재귀, 또는 stack으로 구현

### BFS
queue로 구현

--- 
## 트리순회
전위순회, 중위순회, 후위순회

--- 
## 완전탐색
입력 N <= 100

--- 
## 백트래킹


--- 
## 비트마스킹


--- 
## 그리디
강노 참고

--- 
## 라인스위핑


--- 
## 투포인터


--- 
## LIS


--- 
## 이분탐색
top-down 
```
binary_search();
```

--- 
## DP
bottom-up 방식

--- 
## 최단거리


--- 
## 펜윅트리

--- 
